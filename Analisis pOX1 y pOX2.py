# -*- coding: utf-8 -*-
"""Agudelo_Jonathan_Entrega 2

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/15HV2SfblU1a8X6EKnE6EZv46FIIuZFnS
"""

#@title  Entrega 1 - Jonathan Agudelo
#----------------------------------- Librerias y funciones ----------------------------------------#
from matplotlib.ticker import FuncFormatter
import matplotlib.pyplot as plt
from google.colab import drive
import seaborn as sns
import pandas as pd
import numpy as np
import random
from matplotlib.ticker import MaxNLocator
#----------------------------------- Lectura de los archivos --------------------------------------#
drive.mount('/content/drive')
file_paths = {
    "pOX1_Ames": "/content/drive/My Drive/Entrega 2/pOX1_ames.fasta",
    "pOX2_Ames": "/content/drive/My Drive/Entrega 2/pOX2_ames.fasta",
}
file_path1 = file_paths["pOX1_Ames"]
file_path2 = file_paths["pOX2_Ames"]
#-------------------------- Parametros para la lectura y graficaciòn-------------------------------#
#-------------------------- Parámetros para la lectura y graficación -------------------------------#
WINDOW_SIZE = 10000  # Tamaño de la ventana (segmento) para calcular el contenido GC/TA
STEP_SIZE = 1000     # Tamaño del paso para mover la ventana a lo largo de la secuencia
sequence1 = ""       # Inicializa una variable para almacenar la secuencia de pOX1
sequence2 = ""       # Inicializa una variable para almacenar la secuencia de pOX2

# ------------------------ Lectura del archivo de secuencia pOX1 -----------------------------------#
with open(file_path1, 'r') as file:           # Abre el archivo de la secuencia de pOX1 en modo lectura
    next(file)                                # Salta la primera línea (generalmente encabezado o identificador)
    for line in file:                         # Itera sobre cada línea del archivo
        sequence1 += line.strip()             # Elimina saltos de línea y concatena la secuencia a la variable sequence1

# ------------------------ Lectura del archivo de secuencia pOX2 -----------------------------------#
with open(file_path2, 'r') as file:           # Abre el archivo de la secuencia de pOX2 en modo lectura
    next(file)                                # Salta la primera línea (generalmente encabezado o identificador)
    for line in file:                         # Itera sobre cada línea del archivo
        sequence2 += line.strip()             # Elimina saltos de línea y concatena la secuencia a la variable sequence2

# --------------------- Listas donde se almacenan los resultados de las funciones -------------------#
pos_pOX1 = []   # Almacena las posiciones de las ventanas de pOX1 en el cálculo de GC/TA
pos_pOX2 = []   # Almacena las posiciones de las ventanas de pOX2 en el cálculo de GC/TA
gc_pOX1 = []    # Almacena el contenido GC calculado para cada ventana de pOX1
gc_pOX2 = []    # Almacena el contenido GC calculado para cada ventana de pOX2
ta_pOX1 = []    # Almacena el contenido TA calculado para cada ventana de pOX1
ta_pOX2 = []    # Almacena el contenido TA calculado para cada ventana de pOX2
gc_o_ = []      # Almacena almacenar el contenido GC de la secuencia original de pOX1
gc_mut_ = []    # Almacena el contenido GC de la secuencia mutada de pOX1
gc_o_2 = []     # Almacena el contenido GC de la secuencia original de pOX2
gc_mut_2 = []   # Almacena el contenido GC de la secuencia mutada de pOX2

#------------------------------- Calculo del contenido de GC y TA ---------------------------------#
def gc_ta_content(sequence):
    sequence = sequence.upper()
    sequence = sequence.replace("\n", "")
    G_count = sequence.count("G")
    C_count = sequence.count("C")
    T_count = sequence.count("T")
    A_count = sequence.count("A")
    gc_content = (G_count + C_count) / len(sequence) * 100
    ta_content = (A_count + T_count) / len(sequence) * 100
    return gc_content, ta_content
#------------------------------------ Insercion de Mutaciones--------------------------------------#
def mutaciones(sequence):
    st = random.randint(2000, 9000)      # Inicio aleatorio de la secuencia
    min = 25000                          # Longitud mínima del segmento que se va a mutar
    end = st + random.randint(min, len(sequence) - st)  # Final del segmento
    seg = sequence[st:end]               # Selección del segmento aleatorio a mutar
    mut = (end - st) // 25               # Determina el número de mutaciones (1 cada 25 pb)
    mut_seg = list(seg)                  # Convierte la secuencia seleccionada a lista para poder modificarla

    for base in range(mut):               # Realiza las mutaciones en el segmento
        mut_p = random.randint(0, len(mut_seg) - 1)  # Se selecciona un punto aleatorio dentro del segmento
        # Transiciones: G ↔ A, C ↔ T
        if mut_seg[mut_p] == 'G':        # Si es una 'G', muta a 'A'
            mut_seg[mut_p] = 'A'         # G → A (purinas)
        elif mut_seg[mut_p] == 'A':      # Si es una 'A', muta a 'G'
            mut_seg[mut_p] = 'G'         # A → G (purinas)
        elif mut_seg[mut_p] == 'C':      # Si es una 'C', muta a 'T'
            mut_seg[mut_p] = 'T'         # C → T (pirimidinas)
        elif mut_seg[mut_p] == 'T':      # Si es una 'T', muta a 'C'
            mut_seg[mut_p] = 'C'         # T → C (pirimidinas)

    # Translocaciones (se cambian segmentos dentro del mismo fragmento)
    if len(mut_seg) > 500:              # Solo hace translocaciones si hay más de 500 bases en el segmento
        st_1 = random.randint(0, len(mut_seg) - 500)  # Selecciona aleatoriamente el inicio del segmento a translocar
        end_1 = st_1 + 500                            # Define el final del segmento a translocar (500 bases)
        seg_transl = mut_seg[st_1:end_1]              # Extrae el segmento que será translocado
        st_2 = random.randint(0, len(mut_seg) - 500)  # Selecciona una ubicación aleatoria para insertar la translocación
        del mut_seg[st_1:end_1]                       # Elimina el segmento original en la posición de inicio
        mut_seg[st_1:end_1] = seg_transl              # Inserta el segmento translocado en la nueva posición

    # Reconstrucción de la secuencia mutada:
    mutated_sequence = sequence[:st] + ''.join(mut_seg) + sequence[end:] # Se unen las partes de la secuencia original con la mutada
    return mutated_sequence, st, end        # Devuelve la secuencia mutada junto con las posiciones de inicio y final del segmento mutado

seq_mut1, st_mut, end_mut = mutaciones(sequence1)     # Aplica la mutación a pOX1
seq_mut2, st_mut2, end_mut2 = mutaciones(sequence2)   # Aplica la mutación a pOX2

#---------------------------- Cálculo de los contenidos en cada secuencia --------------------------
for x in range(0, len(sequence1), STEP_SIZE):  # Recorre la secuencia original en pasos de STEP_SIZE
    temp = sequence1[x:x + WINDOW_SIZE]        # Extrae el segmento de la secuencia de tamaño WINDOW_SIZE
    pos_pOX1.append(x)                         # Almacena la posición de inicio del segmento
    gc, ta = gc_ta_content(temp)               # Calcula el contenido de GC y TA para el segmento
    gc_pOX1.append(gc)                         # Guarda el contenido GC
    ta_pOX1.append(ta)                         # Guarda el contenido TA

for x in range(0, len(sequence2), STEP_SIZE):  # Repite el proceso para la segunda secuencia (pOX2)
    temp = sequence2[x:x + WINDOW_SIZE]        # Extrae el segmento de la secuencia
    pos_pOX2.append(x)                         # Almacena la posición de inicio
    gc, ta = gc_ta_content(temp)               # Calcula el contenido de GC y TA
    gc_pOX2.append(gc)                         # Guarda el contenido GC
    ta_pOX2.append(ta)                         # Guarda el contenido TA

#------------------------------- Cálculo del contenido GC para la secuencia mutada ----------------#
for x in range(0, len(seq_mut1), STEP_SIZE):   # Recorre la secuencia mutada en pasos de STEP_SIZE
    temp_o = sequence1[x:x + WINDOW_SIZE]      # Extrae el segmento original de la secuencia pOX1
    temp_mut = seq_mut1[x:x + WINDOW_SIZE]     # Extrae el segmento de la secuencia mutada
    gc_o, _ = gc_ta_content(temp_o)            # Calcula el contenido GC para la secuencia original
    gc_mut, _ = gc_ta_content(temp_mut)        # Calcula el contenido GC para la secuencia mutada
    gc_o_.append(gc_o)                         # Almacena el contenido GC de la secuencia original
    gc_mut_.append(gc_mut)                     # Almacena el contenido GC de la secuencia mutada

for x in range(0, len(seq_mut2), STEP_SIZE):   # Recorre la secuencia original de pOX2 en pasos de STEP_SIZE
    temp_o = sequence2[x:x + WINDOW_SIZE]      # Extrae el segmento original de la secuencia pOX2
    temp_mut = seq_mut2[x:x + WINDOW_SIZE]     # Extrae el segmento de la secuencia mutada
    gc_o, _ = gc_ta_content(temp_o)            # Calcula el contenido GC para la secuencia original
    gc_mut, _ = gc_ta_content(temp_mut)        # Calcula el contenido GC para la secuencia mutada
    gc_o_2.append(gc_o)                        # Almacena el contenido GC de la secuencia original de pOX2
    gc_mut_2.append(gc_mut)                    # Almacena el contenido GC de la secuencia mutada de pOX2

# ---------------------- Almacenamos los datos en un DataFrame de pandas ------------------------#
df = pd.DataFrame({
    'Original': gc_o_,                        # Columna con los valores de GC para la secuencia original
    'Mutado': gc_mut_                         # Columna con los valores de GC para la secuencia mutada
    })
df_pOX2 = pd.DataFrame({
    'Original': gc_o_2,                       # Columna con los valores de GC para la secuencia original de pOX2
    'Mutado': gc_mut_2                        # Columna con los valores de GC para la secuencia mutada de pOX2
    })
#--------------------------------------------- Graficacion-----------------------------------------#
# ------------------------ Graficos de linea de los contenidos de GC y TA -------------------------#
sns.set(style="whitegrid", palette="muted", font_scale=1.2)
plt.figure(1, figsize=(12, 7))
# Primer panel: Contenido GC para pOX1 y pOX2
plt.subplot(121)
sns.lineplot(x=[pos / 1000 for pos in pos_pOX1], y=gc_pOX1, label="pOX1", color='royalblue', linewidth=2)
sns.lineplot(x=[pos / 1000 for pos in pos_pOX2], y=gc_pOX2, label="pOX2", color='darkorange', linewidth=2)
plt.axhline(sum(gc_pOX1) / len(gc_pOX1), color='royalblue', linestyle='--', linewidth=2, label="Promedio pOX1")
plt.axhline(sum(gc_pOX2) / len(gc_pOX2), color='darkorange', linestyle='--', linewidth=2, label="Promedio pOX2")
plt.xlabel("Posición (x10³ bp)", fontsize=14)
plt.ylabel("Contenido GC (%)", fontsize=14)
plt.title("Contenido GC de pOX1 y pOX2", fontsize=16)
plt.legend(title="Secuencias", fontsize=9, loc = "best")
plt.grid(True, linestyle=":", linewidth=0.5)                 # SIrve para visualizar las cuadriculas del grafico
plt.gca().xaxis.set_major_locator(MaxNLocator(integer=True, prune='lower'))    # Cuantos valores optimizan la visualizacion del eje x
# Segundo panel: Contenido TA para pOX1 y pOX2
plt.subplot(122)
sns.lineplot(x=[pos / 1000 for pos in pos_pOX1], y=ta_pOX1, label="pOX1", color='forestgreen', linewidth=2)
sns.lineplot(x=[pos / 1000 for pos in pos_pOX2], y=ta_pOX2, label="pOX2", color='tomato', linewidth=2)
plt.axhline(sum(ta_pOX1) / len(ta_pOX1), color='forestgreen', linestyle='--', linewidth=2, label="Promedio pOX1")
plt.axhline(sum(ta_pOX2) / len(ta_pOX2), color='tomato', linestyle='--', linewidth=2, label="Promedio pOX2")
plt.xlabel("Posición (x10³ bp)", fontsize=14)
plt.ylabel("Contenido TA (%)", fontsize=14)
plt.title("Contenido TA de pOX1 y pOX2", fontsize=16)
plt.legend(title="Secuencias", fontsize=9, loc = "best")
plt.grid(True, linestyle=":", linewidth=0.5)
plt.gca().xaxis.set_major_locator(MaxNLocator(integer=True, prune='lower'))
plt.tight_layout()
plt.show()
#---------------------------- Histogramas de los contenidos GC y TA -------------------------------#
plt.figure(figsize=(12, 6))
# Primer panel: Histograma de contenido GC
plt.subplot(121)
sns.histplot(gc_pOX1, color='blue', kde=True, label="GC_pXO1", stat='count', bins=30)
sns.histplot(gc_pOX2, color='orange', kde=True, label="GC_pXO2", stat='count', bins=30)
plt.xlabel("Contenido GC (%)")
plt.ylabel("Frecuencia")
plt.title("Distribución del Contenido GC")
plt.legend(loc="best")
plt.grid(True)
# Segundo panel: Histograma de contenido TA
plt.subplot(122)
sns.histplot(ta_pOX1, color='green', kde=True, label="TA_pXO1", stat='count', bins=30)
sns.histplot(ta_pOX2, color='red', kde=True, label="TA_pXO2", stat='count', bins=30)
plt.xlabel("Contenido TA (%)")
plt.ylabel("Frecuencia")
plt.title("Distribución del Contenido TA")
plt.legend(loc="best")
plt.grid(True)
plt.tight_layout()
plt.show()
# -------------------------------Graficos de cajas de mutaciones ----------------------------------#
plt.figure(4, figsize=(8, 6))
# Primer panel (pOX1)
plt.subplot(121)
sns.boxplot(data=df, palette="Set2", width=0.4)
plt.title(f"GC Original vs. Mutado en pOX1 \n Rango: {st_mut}-{end_mut}")
plt.ylabel("Contenido GC (%)")
plt.grid(True)
# Segundo panel (pOX2)
plt.subplot(122)
sns.boxplot(data=df_pOX2, palette="Set2", width=0.4)
plt.title(f"GC Original vs. Mutado en pOX2 \n Rango: {st_mut2}-{end_mut2}")
plt.ylabel("Contenido GC (%)")
plt.grid(True)
plt.tight_layout()
plt.show()
# -------------------------Graficos de dispercion para frecuencias de GC --------------------------#
plt.figure(4,figsize=(10, 6))
promedio_gc = gc_pOX1
posiciones_gc = pos_pOX1
frecuencias_gc = np.random.randint(1, 50, size=len(promedio_gc))
sns.scatterplot(x=posiciones_gc,y=promedio_gc,
    size=frecuencias_gc,hue=promedio_gc,
    palette="viridis",sizes=(20, 200),
    alpha=0.7,edgecolor="w")
norm = plt.Normalize(vmin=min(promedio_gc), vmax=max(promedio_gc))
sm = plt.cm.ScalarMappable(cmap="viridis", norm=norm)
sm.set_array([])
cbar = plt.colorbar(sm, ax=plt.gca())
cbar.set_label("Contenido GC (%)", fontsize=12)
plt.title("Distribución de GC por Posición", fontsize=14)
plt.xlabel("Posición (bp)", fontsize=12)
plt.tight_layout()
plt.show()
#-------------------------------pOX2 ------------------------------#
plt.figure(5,figsize=(10, 6))
promedio_gc1 = gc_pOX2
posiciones_gc1 = pos_pOX2
frecuencias_gc1 = np.random.randint(1, 50, size=len(promedio_gc1))
sns.scatterplot(x=posiciones_gc1,y=promedio_gc1,
    size=frecuencias_gc1,hue=promedio_gc1,
    palette="viridis",sizes=(20, 200),
    alpha=0.7,edgecolor="w")
norm = plt.Normalize(vmin=min(promedio_gc1), vmax=max(promedio_gc1))
sm = plt.cm.ScalarMappable(cmap="viridis", norm=norm)
sm.set_array([])
cbar = plt.colorbar(sm, ax=plt.gca())
cbar.set_label("Contenido GC (%)", fontsize=12)
plt.title("Distribución de GC por Posición", fontsize=14)
plt.xlabel("Posición (bp)", fontsize=12)
plt.tight_layout()
plt.show()
####################################################################################################